<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Portal</title>
  <style>
    body { 
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);
    
    const portalVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const portalFragmentShader = `
  uniform float time;
  varying vec2 vUv;
  
  float circle(vec2 uv, float radius, float softness) {
    float dist = length(uv - vec2(0.5));
    return 1.0 - smoothstep(radius - softness, radius, dist);
  }
  
  void main() {
    vec2 centeredUv = vUv - 0.5;
    float angle = atan(centeredUv.y, centeredUv.x);
    float radius = length(centeredUv);
    
    float distortion = sin(angle * 8.0 + time * 2.0) * 0.05 + 
                      sin(angle * 5.0 - time * 1.7) * 0.03;
    float distortedRadius = radius + distortion * (0.3 - radius) * 1.5;
    
    float colorMix = sin(time * 0.5) * 0.5 + 0.5;
    vec3 portalCore = mix(vec3(1.0, 0.8, 0.2), vec3(1.0, 0.5, 0.0), colorMix);
    vec3 portalOuter = mix(vec3(0.5, 0.1, 0.8), vec3(0.1, 0.4, 0.8), colorMix);
    
    // Adjusted mask for a more solid appearance
    float mask = circle(vUv, 0.45, 0.05); // Reduced softness from 0.1 to 0.05 for sharper edges
    float innerMask = circle(vUv, 0.25, 0.05); // Adjusted for solidity
    
    float pulseIntensity = 1.0 + sin(time * 2.0) * 0.3;
    vec3 finalColor = mix(portalOuter, portalCore, innerMask) * pulseIntensity;
    
    if (distortedRadius > 0.3 && distortedRadius < 0.4) {
      float edgeIntensity = (distortedRadius - 0.3) / 0.1;
      finalColor += vec3(0.8, 0.5, 1.0) * edgeIntensity * sin(angle * 20.0 + time * 5.0) * 0.3;
    }
    
    float glow = exp(-distortedRadius * 5.0) * 2.0;
    finalColor += portalCore * glow * pulseIntensity;
    
    // Ensure opacity is solid within the portal, only fading slightly at the very edge
    float solidOpacity = clamp(mask, 0.8, 1.0); // Minimum opacity of 0.8 for solidity
    
    gl_FragColor = vec4(finalColor, solidOpacity);
  }
`;
    
    const portalMaterial = new THREE.ShaderMaterial({
      vertexShader: portalVertexShader,
      fragmentShader: portalFragmentShader,
      uniforms: { time: { value: 0 } },
      transparent: true,
      depthWrite: false,
    });
    
    const portalGeometry = new THREE.CircleGeometry(2, 64);
    const portal = new THREE.Mesh(portalGeometry, portalMaterial);
    scene.add(portal);
    
    const starCount = 2500;
    const starGeometry = new THREE.BufferGeometry();
    
    const starVertexShader = `
      attribute vec3 color;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
    
    const starFragmentShader = `
      varying vec3 vColor;
      uniform float time;
      void main() {
        float distance = length(gl_PointCoord - vec2(0.5));
        if (distance > 0.5) discard;
        float opacity = 1.0 - smoothstep(0.3, 0.5, distance);
        vec3 orange = vec3(1.0, 0.6, 0.0);
        vec3 blue = vec3(0.1, 0.4, 0.8);
        vec3 white = vec3(1.0, 1.0, 1.0);
        float mixFactor1 = sin(time + distance * 10.0) * 0.5 + 0.5;
        float mixFactor2 = cos(time + distance * 5.0) * 0.5 + 0.5;
        vec3 baseColor = mix(orange, blue, mixFactor1);
        vec3 finalColor = mix(baseColor, white, mixFactor2 * 0.5);
        gl_FragColor = vec4(finalColor * vColor, opacity);
      }
    `;
    
    const starMaterial = new THREE.ShaderMaterial({
      vertexShader: starVertexShader,
      fragmentShader: starFragmentShader,
      uniforms: { time: { value: 0 } },
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    const starSizes = new Float32Array(starCount);
    const starVelocities = new Float32Array(starCount * 3);
    
    const colorPalette = [
      [1.0, 0.6, 0.0], [1.0, 0.8, 0.2], [1.0, 1.0, 0.8],
      [1.0, 0.9, 0.5], [0.95, 0.95, 1.0]
    ];
    
    const minStarSize = 0.15;
    const maxStarSize = 0.35;
    
    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      let x, y, z, distFromCenter;
      do {
        x = (Math.random() - 0.5) * 50;
        y = (Math.random() - 0.5) * 50;
        z = Math.random() * -50 - 10;
        distFromCenter = Math.sqrt(x*x + y*y);
      } while (z > -5 && distFromCenter < 3);
      
      starPositions[i3] = x;
      starPositions[i3 + 1] = y;
      starPositions[i3 + 2] = z;
      
      starVelocities[i3] = 0;
      starVelocities[i3 + 1] = 0;
      starVelocities[i3 + 2] = Math.random() * 0.5 + 0.5;
      
      starSizes[i] = Math.random() * (maxStarSize - minStarSize) + minStarSize;
      
      const colorIndex = Math.floor(Math.random() * colorPalette.length);
      const color = colorPalette[colorIndex];
      starColors[i3] = color[0];
      starColors[i3 + 1] = color[1];
      starColors[i3 + 2] = color[2];
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    
    const starPoints = new THREE.Points(starGeometry, starMaterial);
    scene.add(starPoints);
    
    const rayCount = starCount;
    const rayGeometryArray = [];
    const rayVertexShader = `
      attribute vec3 color;
      varying vec3 vColor;
      varying vec2 vUv;
      void main() {
        vColor = color;
        vUv = vec2(position.z, 0.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const rayFragmentShader = `
      uniform float time;
      varying vec3 vColor;
      varying vec2 vUv;
      void main() {
        vec3 orange = vec3(1.0, 0.6, 0.0);
        vec3 blue = vec3(0.1, 0.4, 0.8);
        vec3 white = vec3(1.0, 1.0, 1.0);
        float mixFactor1 = sin(time + vUv.x * 5.0) * 0.5 + 0.5;
        float mixFactor2 = cos(time + vUv.x * 3.0) * 0.5 + 0.5;
        vec3 baseColor = mix(orange, blue, mixFactor1);
        vec3 finalColor = mix(baseColor, white, mixFactor2 * 0.5);
        float opacity = smoothstep(-2.0, 0.0, vUv.x);
        gl_FragColor = vec4(finalColor * vColor, opacity);
      }
    `;
    
    const rayMaterial = new THREE.ShaderMaterial({
      vertexShader: rayVertexShader,
      fragmentShader: rayFragmentShader,
      uniforms: { time: { value: 0 } },
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const rays = [];
    
    for (let i = 0; i < rayCount; i++) {
      const rayGeometry = new THREE.BufferGeometry();
      const rayPositions = new Float32Array(2 * 3);
      const rayColors = new Float32Array(2 * 3);
      
      rayPositions[0] = starPositions[i * 3];
      rayPositions[1] = starPositions[i * 3 + 1];
      rayPositions[2] = starPositions[i * 3 + 2];
      rayPositions[3] = starPositions[i * 3];
      rayPositions[4] = starPositions[i * 3 + 1];
      rayPositions[5] = starPositions[i * 3 + 2];
      
      rayColors[0] = starColors[i * 3];
      rayColors[1] = starColors[i * 3 + 1];
      rayColors[2] = starColors[i * 3 + 2];
      rayColors[3] = starColors[i * 3];
      rayColors[4] = starColors[i * 3 + 1];
      rayColors[5] = starColors[i * 3 + 2];
      
      rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
      rayGeometry.setAttribute('color', new THREE.BufferAttribute(rayColors, 3));
      
      const ray = new THREE.Line(rayGeometry, rayMaterial);
      rays.push(ray);
      rayGeometryArray.push(rayGeometry);
      scene.add(ray);
    }
    
    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);
    
    const portalLight = new THREE.PointLight(0xffaa00, 1.5, 10);
    portalLight.position.set(0, 0, 0.1);
    scene.add(portalLight);
    
    const bgGlowGeometry = new THREE.SphereGeometry(40, 32, 32);
    const bgGlowMaterial = new THREE.MeshBasicMaterial({
      color: 0x000833,
      transparent: true,
      opacity: 0.1,
      side: THREE.BackSide
    });
    const bgGlow = new THREE.Mesh(bgGlowGeometry, bgGlowMaterial);
    scene.add(bgGlow);
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    let prevTime = 0;
    function animate(time) {
      const delta = (time - prevTime) / 1000;
      prevTime = time;
      
      portalMaterial.uniforms.time.value = time / 1000;
      starMaterial.uniforms.time.value = time / 1000;
      rayMaterial.uniforms.time.value = time / 1000;
      
      const pulseIntensity = 1.5 + Math.sin(time / 1000 * 2) * 0.5;
      portalLight.intensity = pulseIntensity;
      
      portal.rotation.z += delta * 0.1;
      
      const positions = starPoints.geometry.attributes.position.array;
      const colors = starPoints.geometry.attributes.color.array;
      const sizes = starPoints.geometry.attributes.size.array;
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const distFromCenter = Math.sqrt(positions[i3] * positions[i3] + positions[i3 + 1] * positions[i3 + 1]);
        const angle = Math.atan2(positions[i3 + 1], positions[i3]);
        
        positions[i3 + 2] += starVelocities[i3 + 2] * delta * 15;
        
        if (positions[i3 + 2] > -10 && positions[i3 + 2] < 10) {
          const repulsionForce = 0.1 / Math.max(0.5, distFromCenter);
          positions[i3] += Math.cos(angle + Math.PI/2) * repulsionForce * delta * 8;
          positions[i3 + 1] += Math.sin(angle + Math.PI/2) * repulsionForce * delta * 8;
        }
        
        if (positions[i3 + 2] > -15 && positions[i3 + 2] < 0) {
          starVelocities[i3 + 2] += delta * 0.3;
        }
        
        const rayPositions = rayGeometryArray[i].attributes.position.array;
        const rayColors = rayGeometryArray[i].attributes.color.array;
        rayPositions[0] = positions[i3];
        rayPositions[1] = positions[i3 + 1];
        rayPositions[2] = positions[i3 + 2];
        rayPositions[3] = positions[i3];
        rayPositions[4] = positions[i3 + 1];
        rayPositions[5] = positions[i3 + 2] - 2.0;
        
        rayColors[0] = colors[i3];
        rayColors[1] = colors[i3 + 1];
        rayColors[2] = colors[i3 + 2];
        rayColors[3] = colors[i3];
        rayColors[4] = colors[i3 + 1];
        rayColors[5] = colors[i3 + 2];
        
        rayGeometryArray[i].attributes.position.needsUpdate = true;
        rayGeometryArray[i].attributes.color.needsUpdate = true;
        
        if (positions[i3 + 2] > 5) {
          positions[i3] = (Math.random() - 0.5) * 50;
          positions[i3 + 1] = (Math.random() - 0.5) * 50;
          positions[i3 + 2] = -50;
          
          const newDistFromCenter = Math.sqrt(positions[i3] * positions[i3] + positions[i3 + 1] * positions[i3 + 1]);
          if (newDistFromCenter < 3) {
            positions[i3] *= 3 / newDistFromCenter;
            positions[i3 + 1] *= 3 / newDistFromCenter;
          }
          
          starVelocities[i3 + 2] = Math.random() * 1.0 + 1.0;
          sizes[i] = Math.random() * (maxStarSize - minStarSize) + minStarSize;
          
          const colorIndex = Math.floor(Math.random() * colorPalette.length);
          const color = colorPalette[colorIndex];
          colors[i3] = color[0];
          colors[i3 + 1] = color[1];
          colors[i3 + 2] = color[2];
        }
      }
      
      starPoints.geometry.attributes.position.needsUpdate = true;
      starPoints.geometry.attributes.color.needsUpdate = true;
      starPoints.geometry.attributes.size.needsUpdate = true;
      
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    
    animate(0);
  </script>
</body>
</html>
